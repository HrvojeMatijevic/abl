<!DOCTYPE html>
<html lang="hr">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<head>
<meta charset="utf-8">
<title>Anchor LWW Prototype</title>

<!-- OpenLayers -->
<script src="https://cdn.jsdelivr.net/npm/ol@v10.5.0/dist/ol.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.5.0/ol.css">

<!-- Proj4 + Socket.IO -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>

<style>
* { box-sizing: border-box; }

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;
  font-family: system-ui;
}

#app { position: relative; width: 100%; height: 100%; }
#map { width: 100%; height: 100%; }

/* ===== Topbar ===== */
.topbar {
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  background: rgba(255,255,255,0.95);
  padding: 8px;
  border-radius: 10px;
  display: flex;
  gap: 8px;
  z-index: 1000;
  align-items: center;
}

.topbar select {
  flex: 1;
  padding: 6px;
}

.topbar .nick {
  font-size: 12px;
  opacity: 0.85;
  padding: 0 6px;
  white-space: nowrap;
}

/* ===== Bottom Sheet ===== */
.bottom-sheet {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  background: white;
  border-top-left-radius: 16px;
  border-top-right-radius: 16px;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
  padding: 16px;
  transform: translateY(110%);
  transition: transform 0.3s ease;
  z-index: 1000;
}

.bottom-sheet.active { transform: translateY(0%); }

.bottom-sheet input,
.bottom-sheet select {
  width: 100%;
  padding: 8px;
  margin-bottom: 10px;
  font-size: 16px;
}

.bottom-sheet button {
  padding: 10px;
  font-size: 16px;
  margin-right: 10px;
}

/* ===== Floating Buttons ===== */
.floating-btn {
  position: absolute;
  right: 15px;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: none;
  background: white;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  font-size: 20px;
  z-index: 1000;
}

#locateBtn { bottom: 120px; }
#trackBtn  { bottom: 60px; }

#trackBtn.active {
  background: #2196f3;
  color: white;
}

/* ===== Desktop-only admin panel ===== */
.admin-panel {
  position: absolute;
  top: 60px;
  left: 10px;
  display: flex;
  gap: 8px;
  z-index: 1200;
}

.admin-panel button {
  border: none;
  border-radius: 10px;
  padding: 8px 10px;
  background: rgba(255,255,255,0.95);
  box-shadow: 0 2px 10px rgba(0,0,0,0.15);
  font-size: 12px;
  cursor: pointer;
}

@media (max-width: 768px) {
  .admin-panel { display: none; }
}

/* ===== Toast ===== */
.toast {
  position: absolute;
  bottom: 180px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 14px;
  display: none;
  z-index: 2000;
}
</style>
</head>

<body>
<div id="app">

  <div id="map"></div>

  <div class="topbar">
    <select id="layerSelect"></select>
    <select id="attributeSelect"></select>
    <div class="nick" id="nickBadge"></div>
  </div>

  <!-- Desktop-only admin controls (also gated by nick in JS) -->
  <div class="admin-panel" id="adminPanel" style="display:none;">
    <button id="exportOpsBtn">‚¨áÔ∏è Export ops (GeoJSON)</button>
    <button id="exportStateBtn">‚¨áÔ∏è Export LWW state (GeoJSON)</button>
    <button id="resetBtn">üß® Reset (new epoch)</button>
  </div>

  <div class="bottom-sheet" id="editor">
    <div id="currentValue"></div>
    <div id="inputContainer"></div>
    <button id="saveBtn">Save</button>
    <button id="deleteBtn">Delete</button>
    <button id="cancelBtn">Cancel</button>
  </div>

  <button class="floating-btn" id="locateBtn">üìç</button>
  <button class="floating-btn" id="trackBtn">üõ∞</button>

  <button class="floating-btn" id="disconnectBtn" style="bottom: 180px;">üîå</button>
  <button class="floating-btn" id="reconnectBtn" style="bottom: 240px;">üîÑ</button>

  <div class="toast" id="toast"></div>

  <div id="netStatus" style="
    position:absolute;
    top:60px;
    right:15px;
    background:#4caf50;
    color:white;
    padding:6px 10px;
    border-radius:8px;
    font-size:12px;
    z-index:2000;
  ">ONLINE</div>

</div>

<script>
/* ================= DATA MODEL CONFIG ================= */

const APP_CONFIG = {
  minEditZoom: 18,
  layers: {
    buildings: {
      label: "Buildings",
      attributes: {
        height: { type: "number" },
        status: { type: "enum", values: ["planned", "existing", "demolished"] }
      }
    }
  }
};

// Hardcoded "admin" nick for prototype (UI-gated, not security)
const ADMIN_NICK = "ImController";

/* ================= HELPERS ================= */

function generateUUID() {
  if (window.crypto && crypto.randomUUID) return crypto.randomUUID();
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

function showToast(msg) {
  const t = document.getElementById("toast");
  t.innerText = msg;
  t.style.display = "block";
  setTimeout(() => t.style.display = "none", 2000);
}

function downloadTextFile(filename, text) {
  const blob = new Blob([text], { type: "application/json;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/* ================= NICKNAME ================= */

let USER_NICK = localStorage.getItem("user_nick");
if (!USER_NICK) {
  USER_NICK = prompt("Enter your nickname:", "") || "";
  USER_NICK = USER_NICK.trim();
  if (!USER_NICK) USER_NICK = "anon";
  localStorage.setItem("user_nick", USER_NICK);
}
document.getElementById("nickBadge").innerText = `üë§ ${USER_NICK}`;

/* ================= CLIENT ID + SEQ ================= */

let CLIENT_ID = localStorage.getItem("client_id");
if (!CLIENT_ID) {
  CLIENT_ID = generateUUID();
  localStorage.setItem("client_id", CLIENT_ID);
}

let clientSeq = Number(localStorage.getItem("client_seq") || 0);
function nextClientSeq() {
  clientSeq += 1;
  localStorage.setItem("client_seq", clientSeq);
  return clientSeq;
}

/* ================= EPOCH ================= */

// local epoch: 0 means "unknown yet"
let localEpoch = Number(localStorage.getItem("epoch") || 0);

/* ================= CORE STATE ================= */

let lastTapCoord = null;

// reduced state: Map(key -> winning op)
let anchorState = new Map();

// full log (for export + rebuild)
let op_log = [];

// outbox (offline ops to send later)
let outbox = [];

// dedupe
let seen_op_ids = new Set();

// persistent keys
const LS_KEY_LOG = "op_log";
const LS_KEY_OUTBOX = "outbox";

// config
const CELL_SIZE = 5; // meters

/* ================= PROJECTION ================= */

proj4.defs('EPSG:3765',
  '+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +y_0=0 ' +
  '+ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
);
ol.proj.proj4.register(proj4);
const htrs96 = ol.proj.get('EPSG:3765');


// ================= PRESENCE LAYER =================

let gpsEnabled = false;
let presenceWatchId = null;

const presenceSource = new ol.source.Vector();
const presenceLayer = new ol.layer.Vector({ source: presenceSource });

// nick -> { history: [{x,y,ts}], disconnected: bool, lastUpdate }
const presenceMap = new Map();

const MAX_HISTORY = 3;
const MAX_TIME_WINDOW_MS = 120000;   // 2 minutes
const MAX_TRACK_LENGTH_M = 200;
const STALE_TIMEOUT_MS = 60000;      // 1 minute
const PRESENCE_MOVE_THRESHOLD = 20;  // meters

let lastPresenceCoord = null;


/* ================= MAP ================= */

const DOF = new ol.layer.Tile({
  source: new ol.source.TileWMS({
    url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_lidar_2022_2023/wms',
    params: { 'LAYERS': 'OI.OrthoimageCoverage', 'TILED': true }
  })
});

const gpsSource = new ol.source.Vector();
const gpsLayer = new ol.layer.Vector({ source: gpsSource });

const anchorSource = new ol.source.Vector();
const anchorLayer = new ol.layer.Vector({ source: anchorSource });

const map = new ol.Map({
  target: 'map',
  layers: [DOF, gpsLayer, anchorLayer, presenceLayer],
  view: new ol.View({
    projection: htrs96,
    center: [500000, 5070000],
    zoom: 16
  })
});

/* ================= UI SETUP ================= */

const layerSelect = document.getElementById("layerSelect");
const attributeSelect = document.getElementById("attributeSelect");
const editor = document.getElementById("editor");
const inputContainer = document.getElementById("inputContainer");
const currentValueDiv = document.getElementById("currentValue");

function populateLayers() {
  layerSelect.innerHTML = "";
  for (let key in APP_CONFIG.layers) {
    const opt = document.createElement("option");
    opt.value = key;
    opt.innerText = APP_CONFIG.layers[key].label;
    layerSelect.appendChild(opt);
  }
  populateAttributes();
}

function populateAttributes() {
  attributeSelect.innerHTML = "";
  const layerKey = layerSelect.value;
  const attrs = APP_CONFIG.layers[layerKey].attributes;
  for (let key in attrs) {
    const opt = document.createElement("option");
    opt.value = key;
    opt.innerText = key;
    attributeSelect.appendChild(opt);
  }
}

function buildInput() {
  inputContainer.innerHTML = "";
  const layerKey = layerSelect.value;
  const attrKey = attributeSelect.value;
  const attr = APP_CONFIG.layers[layerKey].attributes[attrKey];

  if (attr.type === "number") {
    const input = document.createElement("input");
    input.type = "number";
    inputContainer.appendChild(input);
  } else if (attr.type === "enum") {
    const select = document.createElement("select");
    // explicit null option
    const emptyOption = document.createElement("option");
    emptyOption.value = "";
    emptyOption.textContent = "-- not set --";
    select.appendChild(emptyOption);

    attr.values.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.innerText = v;
      select.appendChild(opt);
    });
    inputContainer.appendChild(select);
  }
}

layerSelect.addEventListener("change", () => {
  populateAttributes();
  buildInput();
  renderAnchors();
});
attributeSelect.addEventListener("change", () => {
  buildInput();
  renderAnchors();
});

populateLayers();
buildInput();

/* ================= ADMIN UI (nick-gated) ================= */

const adminPanel = document.getElementById("adminPanel");
const exportOpsBtn = document.getElementById("exportOpsBtn");
const exportStateBtn = document.getElementById("exportStateBtn");
const resetBtn = document.getElementById("resetBtn");

const isAdmin = (USER_NICK === ADMIN_NICK);
adminPanel.style.display = isAdmin ? "flex" : "none";

/* ================= ONLINE/OFFLINE (manual) ================= */

const netStatus = document.getElementById("netStatus");
const disconnectBtn = document.getElementById("disconnectBtn");
const reconnectBtn = document.getElementById("reconnectBtn");

/* ================= SOCKET ================= */

//const SERVER_URL = "http://192.168.1.116:2500";
const SERVER_URL = "https://abl-server.onrender.com";

const socket = io(SERVER_URL, {
  autoConnect: true,
  reconnection: true
});

// Manual offline: disable reconnection + disconnect.
// This prevents socket.io from silently reconnecting and flushing buffered emits.
disconnectBtn.onclick = () => {
  socket.io.opts.reconnection = false;
  socket.disconnect();
  showToast("Offline mode");
};

reconnectBtn.onclick = () => {
  socket.io.opts.reconnection = true;
  socket.connect();
  showToast("Reconnecting...");
};

// Debug hooks (optional)
socket.on("connect", () => {
  console.log("Connected to server");
  netStatus.innerText = "ONLINE";

  // --- Redraw user on reconnect ---
  const myEntry = presenceMap.get(USER_NICK);
console.log("Entry on reconnect:", myEntry);
  if (myEntry) {
    myEntry.disconnected = false;
    console.log("Marked as active again");
    renderPresence();
  }

  netStatus.style.background = "#4caf50";
  // ask for sync and flush outbox
  socket.emit("request_sync"); // server may ignore; harmless
  flushOutbox();
});

socket.on("disconnect", (reason) => {
  console.log("Disconnected:", reason);
  netStatus.innerText = "OFFLINE";
  netStatus.style.background = "#f44336";
});

/* ================= LOCAL STORAGE LOAD ================= */

function persistLog() {
  localStorage.setItem(LS_KEY_LOG, JSON.stringify(op_log));
}

function persistOutbox() {
  localStorage.setItem(LS_KEY_OUTBOX, JSON.stringify(outbox));
}

function loadLocalArray(key) {
  const raw = localStorage.getItem(key);
  if (!raw) return null;
  const parsed = JSON.parse(raw);
  if (!Array.isArray(parsed)) throw new Error(`${key} is not an array`);
  return parsed;
}

// load log + outbox early
try {
  const parsedLog = loadLocalArray(LS_KEY_LOG);
  if (parsedLog) {
    op_log = parsedLog;
    op_log.forEach(op => { if (op && op.op_id) seen_op_ids.add(op.op_id); });
    rebuildFromLog();
  }
} catch (e) {
  console.error("Failed to load local op_log:", e);
  localStorage.removeItem(LS_KEY_LOG);
  op_log = [];
  seen_op_ids.clear();
}

try {
  const parsedOutbox = loadLocalArray(LS_KEY_OUTBOX);
  if (parsedOutbox) {
    outbox = parsedOutbox.filter(op => op && op.op_id);
    // also dedupe: if outbox ops already in op_log, keep them but they'll be ignored by server via op_id
  }
} catch (e) {
  console.error("Failed to load local outbox:", e);
  localStorage.removeItem(LS_KEY_OUTBOX);
  outbox = [];
}

/* ================= EPOCH WIPE ================= */

function wipeLocalOpsAndState() {
  op_log = [];
  outbox = [];
  seen_op_ids = new Set();
  anchorState.clear();
  anchorSource.clear();

  localStorage.removeItem(LS_KEY_LOG);
  localStorage.removeItem(LS_KEY_OUTBOX);
  localStorage.removeItem("client_seq"); // optional but matches "reset local data"
  clientSeq = 0;

  renderAnchors();
}

/* ================= SERVER SYNC + EPOCH EVENTS ================= */

// New server event: sync_full {epoch, log}
socket.on("sync_full", ({ epoch, log }) => {
  console.log("sync_full epoch:", epoch, "log:", (log || []).length);

  // epoch mismatch => wipe old universe
  if (typeof epoch === "number" && epoch !== localEpoch) {
    wipeLocalOpsAndState();
    localEpoch = epoch;
    localStorage.setItem("epoch", String(localEpoch));
    showToast(`New epoch ${localEpoch}`);
  } else if (localEpoch === 0 && typeof epoch === "number") {
    // first time
    localEpoch = epoch;
    localStorage.setItem("epoch", String(localEpoch));
  }

  if (Array.isArray(log)) {
    mergeServerLog(log);
  }

  // remove from outbox any ops already seen (server replay)
  outbox = outbox.filter(op => op && !seen_op_ids.has(op.op_id));
  persistOutbox();

  flushOutbox();
});

// Server broadcast: epoch_update {epoch}
socket.on("epoch_update", ({ epoch }) => {
  console.log("epoch_update:", epoch);
  wipeLocalOpsAndState();
  localEpoch = epoch;
  localStorage.setItem("epoch", String(localEpoch));
  showToast(`Reset ‚Üí epoch ${localEpoch}`);
});

// Incoming single op
socket.on("op", (op) => {
  if (!op || !op.op_id) return;

  // Ignore wrong epoch ops
  if (typeof op.epoch === "number" && op.epoch !== localEpoch) {
    return;
  }

  if (!seen_op_ids.has(op.op_id)) {
    op_log.push(op);
    seen_op_ids.add(op.op_id);
    persistLog();
    reduceSingleOp(op);
    renderAnchors();
  }

  // Remove from outbox if confirmed
  outbox = outbox.filter(o => o.op_id !== op.op_id);
  persistOutbox();
});

/* ================= MERGE + OUTBOX ================= */

function mergeServerLog(serverLog) {
  serverLog.forEach(op => {
    if (!op || !op.op_id) return;

    // Ignore wrong epoch entries if present
    if (typeof op.epoch === "number" && op.epoch !== localEpoch) return;

    if (!seen_op_ids.has(op.op_id)) {
      op_log.push(op);
      seen_op_ids.add(op.op_id);
    }
  });

  persistLog();
  rebuildFromLog();
}

function flushOutbox() {
  if (!socket.connected) return;
  if (!outbox.length) return;

  // send all (server dedupe handled client-side and/or server-side by op_id persistence pattern)
  outbox.forEach(op => {
    // ensure epoch is current
    if (typeof op.epoch !== "number") op.epoch = localEpoch;
    socket.emit("op", op);
  });
}

/* ================= LWW / ANCHORS ================= */

function computeAnchorId(layer, x, y) {
  const ax = Math.floor(x / CELL_SIZE);
  const ay = Math.floor(y / CELL_SIZE);
  return `${layer}:${CELL_SIZE}:${ax}:${ay}`;
}

function anchorKey(layer, anchorId, attr) {
  return `${layer}|${anchorId}|${attr}`;
}

function isNewer(opA, opB) {
  if (opA.ts !== opB.ts) return opA.ts > opB.ts;
  if (opA.actor !== opB.actor) return opA.actor > opB.actor;
  if (opA.client_seq !== opB.client_seq) return opA.client_seq > opB.client_seq;
  return opA.op_id > opB.op_id;
}

function reduceSingleOp(op) {
  const anchorId = computeAnchorId(op.layer, op.x, op.y);
  const key = anchorKey(op.layer, anchorId, op.attr);

  const existing = anchorState.get(key);
  if (!existing || isNewer(op, existing)) {
    anchorState.set(key, op);
  }
}

function rebuildFromLog() {
  anchorState.clear();
  op_log.forEach(op => reduceSingleOp(op));
  renderAnchors();
}

function renderAnchors() {
  anchorSource.clear();

  const activeLayer = layerSelect.value;
  const activeAttr  = attributeSelect.value;

  const zoom = map.getView().getZoom();

  if (zoom < APP_CONFIG.minEditZoom - 1) return;

  anchorState.forEach(op => {

    if (op.layer !== activeLayer) return;
    if (op.attr  !== activeAttr)  return;
    if (op.value === null) return;

    const feature = new ol.Feature({
      geometry: new ol.geom.Point([op.x, op.y])
    });

    feature.setStyle(new ol.style.Style({
      image: new ol.style.Circle({
        radius: zoom >= APP_CONFIG.minEditZoom ? 6 : 4,
        fill: new ol.style.Fill({ color: "#d32f2f" }),
        stroke: new ol.style.Stroke({ color: "white", width: 2 })
      }),
      text: zoom >= APP_CONFIG.minEditZoom ? new ol.style.Text({
        text: String(op.value),
        offsetY: -16,
        fill: new ol.style.Fill({ color: "#000" }),
        stroke: new ol.style.Stroke({ color: "#fff", width: 3 })
      }) : undefined
    }));

    anchorSource.addFeature(feature);
  });
}

// rerender on zoom
map.getView().on("change:resolution", renderAnchors);

/* ================= TAP HANDLER ================= */

map.on("singleclick", function(evt) {
  lastTapCoord = evt.coordinate;

  const layer = layerSelect.value;
  const attr = attributeSelect.value;

  const anchorId = computeAnchorId(layer, lastTapCoord[0], lastTapCoord[1]);
  const key = anchorKey(layer, anchorId, attr);
  const winner = anchorState.get(key);

  inputContainer.innerHTML = "";
  const attrConfig = APP_CONFIG.layers[layer].attributes[attr];

  let input;

  if (attrConfig.type === "enum") {
    input = document.createElement("select");

    const emptyOption = document.createElement("option");
    emptyOption.value = "";
    emptyOption.textContent = "-- not set --";
    input.appendChild(emptyOption);

    attrConfig.values.forEach(v => {
      const option = document.createElement("option");
      option.value = v;
      option.textContent = v;
      input.appendChild(option);
    });

    if (winner && winner.value !== null) {
      input.value = String(winner.value);
      currentValueDiv.innerText = "Current: " + winner.value;
    } else {
      currentValueDiv.innerText = "No value";
    }

  } else {
    input = document.createElement("input");
    input.type = attrConfig.type === "number" ? "number" : "text";

    if (winner && winner.value !== null) {
      input.value = winner.value;
      currentValueDiv.innerText = "Current: " + winner.value;
    } else {
      currentValueDiv.innerText = "No value";
    }
  }


  inputContainer.appendChild(input);
  //input.focus();
  input.focus({ preventScroll: true });


  // Enter key triggers save
  input.addEventListener("keydown", function(e) {
    if (e.key === "Enter") {
      e.preventDefault();
      document.getElementById("saveBtn").click();
    }
  });

  editor.classList.add("active");

});

/* ================= SAVE / DELETE ================= */

function makeOp({ layer, attr, value }) {
  return {
    op_id: generateUUID(),
    epoch: localEpoch,                 // ‚úÖ epoch
    layer,
    x: lastTapCoord[0],
    y: lastTapCoord[1],
    attr,
    value,
    ts: Date.now(),
    actor: CLIENT_ID,
    nick: USER_NICK,                   // ‚úÖ nick
    client_seq: nextClientSeq()
  };
}

function appendLocalOp(op) {
  if (seen_op_ids.has(op.op_id)) return;

  op_log.push(op);
  seen_op_ids.add(op.op_id);

  outbox.push(op);

  persistLog();
  persistOutbox();

  reduceSingleOp(op);
  renderAnchors();
}

document.getElementById("saveBtn").onclick = (e) => {
  e.stopPropagation();
  if (!lastTapCoord) return;

  const layer = layerSelect.value;
  const attr = attributeSelect.value;

  const inputEl = inputContainer.querySelector("input, select");
  let value = inputEl ? inputEl.value : null;

  if (value === "") value = null;

  const attrConfig = APP_CONFIG.layers[layer].attributes[attr];
  if (attrConfig.type === "number" && value !== null) value = Number(value);

  const op = makeOp({ layer, attr, value });
  appendLocalOp(op);

  // Important: only emit if connected (no socket.io buffering in "offline mode")
  if (socket && socket.connected) socket.emit("op", op);

  editor.classList.remove("active");
};

document.getElementById("deleteBtn").onclick = (e) => {
  e.stopPropagation();
  if (!lastTapCoord) return;

  const layer = layerSelect.value;
  const attr = attributeSelect.value;

  const op = makeOp({ layer, attr, value: null });
  appendLocalOp(op);

  if (socket && socket.connected) socket.emit("op", op);

  editor.classList.remove("active");
};


document.getElementById("cancelBtn").onclick = (e) => {
  e.stopPropagation();
  editor.classList.remove("active");
  lastTapCoord = null;
};



/* ================= GPS and PRESENCE ================= */

function updateGPS(position) {
  const lon = position.coords.longitude;
  const lat = position.coords.latitude;
  const accuracy = position.coords.accuracy;

  const coord = ol.proj.transform([lon, lat], 'EPSG:4326', 'EPSG:3765');

  gpsSource.clear();

  const point = new ol.Feature(new ol.geom.Point(coord));
  point.setStyle(new ol.style.Style({
    image: new ol.style.Circle({
      radius: 6,
      fill: new ol.style.Fill({ color: "#2196f3" }),
      stroke: new ol.style.Stroke({ color: "white", width: 2 })
    })
  }));

  const circle = new ol.Feature(new ol.geom.Circle(coord, accuracy));
  circle.setStyle(new ol.style.Style({
    fill: new ol.style.Fill({ color: "rgba(33,150,243,0.2)" })
  }));

  gpsSource.addFeature(circle);
  gpsSource.addFeature(point);

  return coord;
}

document.getElementById("locateBtn").onclick = () => {
  navigator.geolocation.getCurrentPosition(
    pos => {
      const coord = updateGPS(pos);
      map.getView().animate({
        center: coord,
        zoom: APP_CONFIG.minEditZoom,
        duration: 500
      });
    },
    () => showToast("GPS failed"),
    { enableHighAccuracy: true }
  );
};

let watchId = null;
let lastCoord = null;


document.getElementById("trackBtn").onclick = function() {
  if (watchId === null) {
    watchId = navigator.geolocation.watchPosition(
      pos => {
        const coord = updateGPS(pos);

        const MOVE_THRESHOLD = 3;

        if (!lastCoord) {
          map.getView().animate({ center: coord, duration: 300 });
          lastCoord = coord;
          return;
        }

        const dx = coord[0] - lastCoord[0];
        const dy = coord[1] - lastCoord[1];
        const distance = Math.sqrt(dx*dx + dy*dy);

        if (distance > MOVE_THRESHOLD) {
          map.getView().animate({ center: coord, duration: 300 });
          lastCoord = coord;
        }
      },
      () => showToast("Last GPS positioning failed"),
      { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 }
    );

    this.classList.add("active");
  } else {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    lastCoord = null;
    this.classList.remove("active");
  }
};








function sendPresence(coord) {
  if (!socket.connected) return;

  socket.emit("presence_update", {
    nick: USER_NICK,
    actor: CLIENT_ID,
    x: coord[0],
    y: coord[1],
    ts: Date.now()
  });
}





socket.on("presence_update", (data) => {

  let entry = presenceMap.get(data.nick);

  if (!entry) {
    entry = {
      history: [],
      disconnected: false
    };
    presenceMap.set(data.nick, entry);
  }

  entry.disconnected = false;  // <--- IMPORTANT

  entry.history.push({
    x: data.x,
    y: data.y,
    ts: data.ts
  });

  if (entry.history.length > MAX_HISTORY) {
    entry.history.shift();
  }

  renderPresence();
});


socket.on("presence_disconnect", ({ nick }) => {
  const entry = presenceMap.get(nick);
  if (!entry) return;

  entry.disconnected = true;

  // Keep only last known location
  if (entry.history.length > 1) {
    entry.history = [entry.history[entry.history.length - 1]];
  }

  renderPresence();
});




setInterval(() => {
  const now = Date.now();
  let changed = false;

  for (let [key, entry] of presenceMap.entries()) {
    if (entry.lastUpdate && now - entry.lastUpdate > STALE_TIMEOUT_MS) {
      presenceMap.delete(key);
      changed = true;
    }
  }

  if (changed) renderPresence();
}, 10000);




function renderPresence() {

  presenceSource.clear();

  presenceMap.forEach((entry, key) => {

    if (!entry.history.length) return;

    const history = entry.history;

    const first = history[0];
    const last  = history[history.length - 1];

    const timeSpan = last.ts - first.ts;

    const dx = last.x - first.x;
    const dy = last.y - first.y;
    const trackLength = Math.sqrt(dx*dx + dy*dy);

    const showDirection =
      history.length >= 2 &&
      timeSpan < MAX_TIME_WINDOW_MS &&
      trackLength < MAX_TRACK_LENGTH_M &&
      !entry.disconnected;

    // Keep same identity color always
    const color = colorFromString(key);

    // ===============================
    // Draw trail (active users only)
    // ===============================
    if (showDirection) {

      const coords = history.map(p => [p.x, p.y]);

      const line = new ol.Feature({
        geometry: new ol.geom.LineString(coords)
      });

      line.setStyle(new ol.style.Style({
        stroke: new ol.style.Stroke({
          color,
          width: 2
        })
      }));

      presenceSource.addFeature(line);

      // Arrow at end
      const prev = history[history.length - 2];
      const angle = Math.atan2(last.y - prev.y, last.x - prev.x);

      const arrow = new ol.Feature({
        geometry: new ol.geom.Point([last.x, last.y])
      });

      arrow.setStyle(new ol.style.Style({
        image: new ol.style.RegularShape({
          points: 3,
          radius: 8,
          rotation: -angle,
          fill: new ol.style.Fill({ color }),
          stroke: new ol.style.Stroke({ color: "#fff", width: 1 })
        })
      }));

      presenceSource.addFeature(arrow);
    }

    // ===============================
    // Always draw last position point
    // ===============================

    const point = new ol.Feature({
      geometry: new ol.geom.Point([last.x, last.y])
    });

    point.setStyle(new ol.style.Style({
      image: new ol.style.Circle({
        radius: 5,
        fill: new ol.style.Fill({ color }),
        stroke: new ol.style.Stroke({ color: "#fff", width: 2 })
      }),
      text: new ol.style.Text({
        text: key,
        offsetY: -14,
        fill: new ol.style.Fill({ color: "#000" }),
        stroke: new ol.style.Stroke({ color: "#fff", width: 3 })
      })
    }));

    presenceSource.addFeature(point);

    // ===============================
    // If disconnected ‚Üí draw square outline
    // ===============================

    if (entry.disconnected) {

      const square = new ol.Feature({
        geometry: new ol.geom.Point([last.x, last.y])
      });

      square.setStyle(new ol.style.Style({
        image: new ol.style.RegularShape({
          points: 4,
          radius: 10,        // slightly larger than circle
          angle: 0,          // straight square
          fill: null,
          stroke: new ol.style.Stroke({
  		color: "#1976d2",   // fixed blue
  		width: 2
	 })
        })
      }));

      presenceSource.addFeature(square);
    }

  });
}




function colorFromString(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = hash % 360;
  return `hsl(${hue}, 70%, 50%)`;
}



// ================= AUTO PRESENCE =================

function startPresenceWatch() {

  if (presenceWatchId !== null) return;

  presenceWatchId = navigator.geolocation.watchPosition(
    pos => {

      const coord = updateGPS(pos);

      if (!lastPresenceCoord) {
        lastPresenceCoord = coord;
        sendPresence(coord);
        return;
      }

      const dx = coord[0] - lastPresenceCoord[0];
      const dy = coord[1] - lastPresenceCoord[1];
      const distance = Math.sqrt(dx*dx + dy*dy);

      if (distance > PRESENCE_MOVE_THRESHOLD) {
        lastPresenceCoord = coord;
        sendPresence(coord);
      }

    },
    err => {
      console.log("Presence GPS error:", err);
    },
    {
      enableHighAccuracy: true,
      maximumAge: 0,
      timeout: 10000
    }
  );
}

// Start immediately on page load
startPresenceWatch();



/* ================= ADMIN ACTIONS ================= */

exportOpsBtn.onclick = () => {
  const fc = {
    type: "FeatureCollection",
    name: "abl_ops",
    crs: { type: "name", properties: { name: "EPSG:3765" } },
    features: op_log.map(op => ({
      type: "Feature",
      geometry: { type: "Point", coordinates: [op.x, op.y] },
      properties: { ...op }
    }))
  };
  downloadTextFile(`abl_ops_epoch_${localEpoch}.geojson`, JSON.stringify(fc, null, 2));
};

exportStateBtn.onclick = () => {
  const features = [];
  anchorState.forEach(op => {
    // export only non-null winners
    if (op.value === null) return;
    const anchor_id = computeAnchorId(op.layer, op.x, op.y);

    features.push({
      type: "Feature",
      geometry: { type: "Point", coordinates: [op.x, op.y] },
      properties: {
        epoch: localEpoch,
        layer: op.layer,
        anchor_id,
        attr: op.attr,
        value: op.value,
        ts: op.ts,
        actor: op.actor,
        nick: op.nick || null,
        client_seq: op.client_seq,
        op_id: op.op_id
      }
    });
  });

  const fc = {
    type: "FeatureCollection",
    name: "abl_lww_state",
    crs: { type: "name", properties: { name: "EPSG:3765" } },
    features
  };

  downloadTextFile(`abl_lww_state_epoch_${localEpoch}.geojson`, JSON.stringify(fc, null, 2));
};

resetBtn.onclick = () => {
  if (!isAdmin) return;

  if (!confirm("Reset system? This creates a NEW epoch and clears ALL data.")) return;
  if (!socket.connected) {
    showToast("Must be online to reset");
    return;
  }

  socket.emit("admin_reset", { nick: USER_NICK });
};

/* ================= INITIAL RENDER ================= */
renderAnchors();
</script>

</body>
</html>
