<!DOCTYPE html>
<html lang="hr">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<head>
<meta charset="utf-8">
<title>Anchor LWW Prototype</title>

<!-- OpenLayers -->
<script src="https://cdn.jsdelivr.net/npm/ol@v10.5.0/dist/ol.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.5.0/ol.css">

<!-- Proj4 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.5.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"></script>
<style>
* {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
  height: 100%;
  overflow: hidden;          /* prevents scrolling */
  font-family: system-ui;
}

/* Main app container */
#app {
  position: relative;
  width: 100%;
  height: 100%;
}

/* Map fills container */
#map {
  width: 100%;
  height: 100%;
}

/* ===== Topbar ===== */

.topbar {
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  background: rgba(255,255,255,0.95);
  padding: 8px;
  border-radius: 10px;
  display: flex;
  gap: 8px;
  z-index: 1000;
}

.topbar select {
  flex: 1;
  padding: 6px;
}

/* ===== Bottom Sheet ===== */

.bottom-sheet {
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  background: white;
  border-top-left-radius: 16px;
  border-top-right-radius: 16px;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
  padding: 16px;
  transform: translateY(110%);  /* ensure fully hidden */
  transition: transform 0.3s ease;
  z-index: 1000;
}

.bottom-sheet.active {
  transform: translateY(0%);
}

.bottom-sheet input,
.bottom-sheet select {
  width: 100%;
  padding: 8px;
  margin-bottom: 10px;
  font-size: 16px;
}

.bottom-sheet button {
  padding: 10px;
  font-size: 16px;
  margin-right: 10px;
}

/* ===== Floating GPS Buttons ===== */

.floating-btn {
  position: absolute;
  right: 15px;
  width: 48px;
  height: 48px;
  border-radius: 50%;
  border: none;
  background: white;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  font-size: 20px;
  z-index: 1000;
}

#locateBtn { bottom: 120px; }
#trackBtn  { bottom: 60px; }

#trackBtn.active {
  background: #2196f3;
  color: white;
}

/* ===== Toast ===== */

.toast {
  position: absolute;
  bottom: 180px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 14px;
  display: none;
  z-index: 2000;
}
</style>
</head>

<body>

<div id="app">

  <div id="map"></div>

  <div class="topbar">
    <select id="layerSelect"></select>
    <select id="attributeSelect"></select>
  </div>

  <div class="bottom-sheet" id="editor">
    <div id="currentValue"></div>
    <div id="inputContainer"></div>
    <button id="saveBtn">Save</button>
    <button id="deleteBtn">Delete</button>
  </div>

  <button class="floating-btn" id="locateBtn">üìç</button>
  <button class="floating-btn" id="trackBtn">üõ∞</button>

<button class="floating-btn" id="disconnectBtn" style="bottom: 180px;">üîå</button>
<button class="floating-btn" id="reconnectBtn" style="bottom: 240px;">üîÑ</button>


  <div class="toast" id="toast"></div>


<div id="netStatus" style="
  position:absolute;
  top:60px;
  right:15px;
  background:#4caf50;
  color:white;
  padding:6px 10px;
  border-radius:8px;
  font-size:12px;
  z-index:2000;
">
  ONLINE
</div>


</div>

<script>


/* ================= DAAT MODEL CONFIG ================= */

const APP_CONFIG = {
  minEditZoom: 18,
  layers: {
    buildings: {
      label: "Buildings",
      attributes: {
        height: { type: "number" },
        status: { type: "enum", values: ["planned", "existing", "demolished"] }
      }
    }
  }
};

/* ================= INITS/VARS ================= */


let lastTapCoord = null;

let anchorState = new Map();
// key: layer|anchor_id|attr
// value: winning op

let op_log = [];
let outbox = [];
let seen_op_ids = new Set();
const saved = localStorage.getItem("op_log");

const CELL_SIZE = 5;  // meters

const anchorSource = new ol.source.Vector();
const anchorLayer = new ol.layer.Vector({ source: anchorSource });



function generateUUID() {
  if (window.crypto && crypto.randomUUID) {
    return crypto.randomUUID();
  }

  // Fallback (RFC4122-ish)
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}



/* ================= ONLINE/OFFLINE SUPPORT ================= */

const netStatus = document.getElementById("netStatus");
const disconnectBtn = document.getElementById("disconnectBtn");
const reconnectBtn = document.getElementById("reconnectBtn");

disconnectBtn.onclick = () => {
  if (socket.connected) {
    socket.disconnect();
  }
console.log (" CONNECTED " + socket.connected)
};

reconnectBtn.onclick = () => {
  if (!socket.connected) {
    socket.connect();
  }
  console.log (" CONNECTED " + socket.connected)
};




/* ================= PROJECTION ================= */

proj4.defs('EPSG:3765',
  '+proj=tmerc +lat_0=0 +lon_0=16.5 +k=0.9999 +x_0=500000 +y_0=0 ' +
  '+ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs'
);
ol.proj.proj4.register(proj4);

const htrs96 = ol.proj.get('EPSG:3765');


/* ================= MAP ================= */

const DOF = new ol.layer.Tile({
  source: new ol.source.TileWMS({
    url: 'https://geoportal.dgu.hr/services/inspire/orthophoto_lidar_2022_2023/wms',
    params: { 'LAYERS': 'OI.OrthoimageCoverage', 'TILED': true }
  })
});

const gpsSource = new ol.source.Vector();
const gpsLayer = new ol.layer.Vector({ source: gpsSource });

const map = new ol.Map({
  target: 'map',
  layers: [DOF, gpsLayer],
  view: new ol.View({
    projection: htrs96,
    center: [500000, 5070000],
    zoom: 16
  })
});

map.addLayer(anchorLayer);


/* ================= UI SETUP ================= */

const layerSelect = document.getElementById("layerSelect");
const attributeSelect = document.getElementById("attributeSelect");
const editor = document.getElementById("editor");
const inputContainer = document.getElementById("inputContainer");
const currentValueDiv = document.getElementById("currentValue");

function populateLayers() {
  layerSelect.innerHTML = "";
  for (let key in APP_CONFIG.layers) {
    const opt = document.createElement("option");
    opt.value = key;
    opt.innerText = APP_CONFIG.layers[key].label;
    layerSelect.appendChild(opt);
  }
  populateAttributes();
}

function populateAttributes() {
  attributeSelect.innerHTML = "";
  const layerKey = layerSelect.value;
  const attrs = APP_CONFIG.layers[layerKey].attributes;
  for (let key in attrs) {
    const opt = document.createElement("option");
    opt.value = key;
    opt.innerText = key;
    attributeSelect.appendChild(opt);
  }
}

function buildInput() {
  inputContainer.innerHTML = "";
  const layerKey = layerSelect.value;
  const attrKey = attributeSelect.value;
  const attr = APP_CONFIG.layers[layerKey].attributes[attrKey];

  if (attr.type === "number") {
    const input = document.createElement("input");
    input.type = "number";
    inputContainer.appendChild(input);
  }
  else if (attr.type === "enum") {
    const select = document.createElement("select");
    attr.values.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.innerText = v;
      select.appendChild(opt);
    });
    inputContainer.appendChild(select);
  }
}

layerSelect.addEventListener("change", () => {
  populateAttributes();
  buildInput();
});

attributeSelect.addEventListener("change", buildInput);

populateLayers();
buildInput();

/* ================= TAP HANDLER ================= */

map.on("singleclick", function(evt) {

  lastTapCoord = evt.coordinate;

  const layer = layerSelect.value;
  const attr = attributeSelect.value;

  const anchorId = computeAnchorId(layer, lastTapCoord[0], lastTapCoord[1]);
  const key = anchorKey(layer, anchorId, attr);

  const winner = anchorState.get(key);

  const currentValueDiv = document.getElementById("currentValue");
  const inputContainer = document.getElementById("inputContainer");

  inputContainer.innerHTML = "";

  const attrConfig = APP_CONFIG.layers[layer].attributes[attr];

  let input;

  if (attrConfig.type === "enum") {

    input = document.createElement("select");


// Add explicit null option
  const emptyOption = document.createElement("option");
  emptyOption.value = "";
  emptyOption.textContent = "-- not set --";
  input.appendChild(emptyOption);


    attrConfig.values.forEach(v => {
      const option = document.createElement("option");
      option.value = v;           // string
      option.textContent = v;
      input.appendChild(option);
    });

    if (winner && winner.value !== null) {
      input.value = String(winner.value);
      currentValueDiv.innerText = "Current: " + winner.value;
    } else {
      currentValueDiv.innerText = "No value";
    }

  } else {

    input = document.createElement("input");
    input.type = attrConfig.type === "number" ? "number" : "text";

    if (winner && winner.value !== null) {
      input.value = winner.value;
      currentValueDiv.innerText = "Current: " + winner.value;
    } else {
      currentValueDiv.innerText = "No value";
    }

  }

  inputContainer.appendChild(input);

  editor.classList.add("active");
});




/* ================= SAVE / DELETE ================= */

document.getElementById("saveBtn").onclick = (e) => {
  e.stopPropagation();

  if (!lastTapCoord) return;

  const layer = layerSelect.value;
  const attr = attributeSelect.value;

  const inputEl = inputContainer.querySelector("input, select");
  
  let value = inputEl ? inputEl.value : null;

  if (value === "") {
    value = null;
  }

  const attrConfig = APP_CONFIG.layers[layer].attributes[attr];
  if (attrConfig.type === "number" && value !== null) {
    value = Number(value);
  }

  const op = {
    op_id: generateUUID(),
    layer: layer,
    x: lastTapCoord[0],
    y: lastTapCoord[1],
    attr: attr,
    value: value,
    ts: Date.now(),
    actor: CLIENT_ID,
    client_seq: nextClientSeq()
  };

  appendLocalOp(op);

  if (socket && socket.connected) {
    socket.emit("op", op);
  }

  editor.classList.remove("active");
};


document.getElementById("deleteBtn").onclick = (e) => {
  e.stopPropagation();

  if (!lastTapCoord) return;

  const layer = layerSelect.value;
  const attr = attributeSelect.value;

  const op = {
    op_id: generateUUID(),
    layer: layer,
    x: lastTapCoord[0],
    y: lastTapCoord[1],
    attr: attr,
    value: null,
    ts: Date.now(),
    actor: CLIENT_ID,
    client_seq: nextClientSeq()
  };

  appendLocalOp(op);

  if (socket && socket.connected) {
    socket.emit("op", op);
  }

  editor.classList.remove("active");
};

/* ================= GPS ================= */

let watchId = null;

function showToast(msg) {
  const t = document.getElementById("toast");
  t.innerText = msg;
  t.style.display = "block";
  setTimeout(() => t.style.display = "none", 2000);
}

function updateGPS(position) {
  const lon = position.coords.longitude;
  const lat = position.coords.latitude;
  const accuracy = position.coords.accuracy;

  const coord = ol.proj.transform(
    [lon, lat],
    'EPSG:4326',
    'EPSG:3765'
  );

  gpsSource.clear();

  const point = new ol.Feature(new ol.geom.Point(coord));
  point.setStyle(new ol.style.Style({
    image: new ol.style.Circle({
      radius: 6,
      fill: new ol.style.Fill({ color: "#2196f3" }),
      stroke: new ol.style.Stroke({ color: "white", width: 2 })
    })
  }));

  const circle = new ol.Feature(
    new ol.geom.Circle(coord, accuracy)
  );
  circle.setStyle(new ol.style.Style({
    fill: new ol.style.Fill({ color: "rgba(33,150,243,0.2)" })
  }));

  gpsSource.addFeature(circle);
  gpsSource.addFeature(point);

  return coord;
}

document.getElementById("locateBtn").onclick = () => {
  navigator.geolocation.getCurrentPosition(
    pos => {
      const coord = updateGPS(pos);
      map.getView().animate({
        center: coord,
        zoom: APP_CONFIG.minEditZoom,
        duration: 500
      });
    },
    () => showToast("GPS failed"),
    { enableHighAccuracy: true }
  );
};



let lastCoord = null;

document.getElementById("trackBtn").onclick = function() {

  if (watchId === null) {

    watchId = navigator.geolocation.watchPosition(
      pos => {

        const coord = updateGPS(pos);

        // ---- movement threshold in meters ----
        const MOVE_THRESHOLD = 3;  

        if (!lastCoord) {
          // first fix ‚Üí center immediately
          map.getView().animate({
            center: coord,
            duration: 300
          });
          lastCoord = coord;
          return;
        }

        // compute distance in meters (EPSG:3765 is metric)
        const dx = coord[0] - lastCoord[0];
        const dy = coord[1] - lastCoord[1];
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > MOVE_THRESHOLD) {

          map.getView().animate({
            center: coord,
            duration: 300
          });

          lastCoord = coord;
        }

      },
      () => showToast("LAst GPS positioning failed"),
      {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 10000
      }
    );

    this.classList.add("active");

  } else {

    navigator.geolocation.clearWatch(watchId);
    watchId = null;
    lastCoord = null;  // reset
    this.classList.remove("active");

  }
};




// ========================================================================================
// 					SOCKET + SYNC LAYER
// ========================================================================================

// ================= CLIENT ID =================

let CLIENT_ID = localStorage.getItem("client_id");
if (!CLIENT_ID) {
  CLIENT_ID = generateUUID();
  localStorage.setItem("client_id", CLIENT_ID);
}

let clientSeq = Number(localStorage.getItem("client_seq") || 0);

function nextClientSeq() {
  clientSeq += 1;
  localStorage.setItem("client_seq", clientSeq);
  return clientSeq;
}


const SERVER_URL = "http://192.168.1.116:2500"; // adjust IP

const socket = io(SERVER_URL, {
  autoConnect: true,
  reconnection: true
});



// ----------------------
// Load localStorage on startup
// ----------------------

if (saved) {
  try {
    const parsed = JSON.parse(saved);

    console.log("Parsed OK");

    if (!Array.isArray(parsed)) {
      throw new Error("Invalid log format");
    }

    op_log = parsed;
    op_log.forEach(op => {
      if (op && op.op_id) {
        seen_op_ids.add(op.op_id);
      }
    });

    console.log("Before rebuild");
    rebuildFromLog();
    console.log("After rebuild");

  } catch (e) {
    console.error("Loader error:", e);
    console.warn("Local log invalid. Resetting.");
    localStorage.removeItem("op_log");
    op_log = [];
    seen_op_ids.clear();
  }
}


// ----------------------
// Persistence helper
// ----------------------

function persistLog() {
  localStorage.setItem("op_log", JSON.stringify(op_log));
}

// ----------------------
// Merge server log
// ----------------------

function mergeServerLog(serverLog) {

  serverLog.forEach(op => {
    if (!seen_op_ids.has(op.op_id)) {
      op_log.push(op);
      seen_op_ids.add(op.op_id);
    }
  });
  
  persistLog();
  rebuildFromLog();
}

// ----------------------
// Flush outbox
// ----------------------

function flushOutbox() {
  if (!socket.connected) return;

  outbox.forEach(op => {
    socket.emit("op", op);
  });
}

// ----------------------
// Append local op
// ----------------------

function appendLocalOp(op) {

  if (seen_op_ids.has(op.op_id)) return;

  op_log.push(op);
  seen_op_ids.add(op.op_id);
  outbox.push(op);

  persistLog();
  reduceSingleOp(op); // apply LWW reduction
  renderAnchors();
}

// ----------------------
// Socket events
// ----------------------

socket.on("connect", () => {
  console.log("Connected to server");
  netStatus.innerText = "ONLINE";
  netStatus.style.background = "#4caf50";
  flushOutbox();
});

socket.on("disconnect", () => {
  console.log("Disconnected from server");
  netStatus.innerText = "OFFLINE";
  netStatus.style.background = "#f44336";
});


socket.on("full_log", (serverLog) => {
  console.log("Received full_log:", serverLog.length);
  mergeServerLog(serverLog);
  flushOutbox();
});

socket.on("op", (op) => {

  if (!seen_op_ids.has(op.op_id)) {
    op_log.push(op);
    seen_op_ids.add(op.op_id);
    persistLog();
    reduceSingleOp(op);
    renderAnchors();
  }

  // Remove from outbox if confirmed
  outbox = outbox.filter(o => o.op_id !== op.op_id);
});



//==========================================================================
//			LWW
//==========================================================================

function computeAnchorId(layer, x, y) {
  const ax = Math.floor(x / CELL_SIZE);
  const ay = Math.floor(y / CELL_SIZE);
  return `${layer}:${CELL_SIZE}:${ax}:${ay}`;
}


function anchorKey(layer, anchorId, attr) {
  return `${layer}|${anchorId}|${attr}`;
}


function isNewer(opA, opB) {
  if (opA.ts !== opB.ts) return opA.ts > opB.ts;
  if (opA.actor !== opB.actor) return opA.actor > opB.actor;
  if (opA.client_seq !== opB.client_seq) return opA.client_seq > opB.client_seq;
  return opA.op_id > opB.op_id;
}



function reduceSingleOp(op) {
  const anchorId = computeAnchorId(op.layer, op.x, op.y);
  const key = anchorKey(op.layer, anchorId, op.attr);

  const existing = anchorState.get(key);

  if (!existing || isNewer(op, existing)) {
    anchorState.set(key, op);
  }

}


function rebuildFromLog() {

  anchorState.clear();

  op_log.forEach(op => {
    const anchorId = computeAnchorId(op.layer, op.x, op.y);
    const key = anchorKey(op.layer, anchorId, op.attr);

    const existing = anchorState.get(key);

    if (!existing || isNewer(op, existing)) {
      anchorState.set(key, op);
    }
  });

  renderAnchors();
}


function renderAnchors() {

  anchorSource.clear();

  const activeLayer = layerSelect.value;
  const activeAttr  = attributeSelect.value;

  const zoom = map.getView().getZoom();

  // Do not render below minimum zoom threshold
  if (zoom < APP_CONFIG.minEditZoom - 1) {
    return;
  }

  anchorState.forEach(op => {

    // Filter by active layer and attribute
    if (op.layer !== activeLayer) return;
    if (op.attr  !== activeAttr)  return;

    // Skip deleted values
    if (op.value === null) return;

    const feature = new ol.Feature({
      geometry: new ol.geom.Point([op.x, op.y])
    });

    feature.setStyle(new ol.style.Style({

      image: new ol.style.Circle({
        radius: zoom >= APP_CONFIG.minEditZoom ? 6 : 4,
        fill: new ol.style.Fill({ color: "#d32f2f" }),
        stroke: new ol.style.Stroke({ color: "white", width: 2 })
      }),

      text: zoom >= APP_CONFIG.minEditZoom ? new ol.style.Text({
        text: String(op.value),
        offsetY: -16,
        fill: new ol.style.Fill({ color: "#000" }),
        stroke: new ol.style.Stroke({ color: "#fff", width: 3 })
      }) : undefined

    }));

    anchorSource.addFeature(feature);

  });
}



// To rerender upon layer/att change
layerSelect.addEventListener("change", renderAnchors);
attributeSelect.addEventListener("change", renderAnchors);
map.getView().on("change:resolution", renderAnchors);






</script>

</body>
</html>
